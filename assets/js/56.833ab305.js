(window.webpackJsonp=window.webpackJsonp||[]).push([[56],{611:function(v,e,_){"use strict";_.r(e);var c=_(10),d=Object(c.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"前端工程化部分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端工程化部分"}},[v._v("#")]),v._v(" 前端工程化部分")]),v._v(" "),_("h3",{attrs:{id:"webpack-与-grunt、gulp-的不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack-与-grunt、gulp-的不同"}},[v._v("#")]),v._v(" webpack 与 grunt、gulp 的不同？")]),v._v(" "),_("p",[_("code",[v._v("Grunt")]),v._v("、"),_("code",[v._v("Gulp")]),v._v(" 是基于任务运⾏的⼯具： 它们会⾃动执⾏指定的任务，\n就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活\n跃的社区，丰富的插件，能⽅便的打造各种⼯作流。")]),v._v(" "),_("p",[_("code",[v._v("Webpack")]),v._v(" 是基于模块化打包的⼯具: ⾃动化处理模块，"),_("code",[v._v("webpack")]),v._v(" 把⼀\n切当成模块，当 "),_("code",[v._v("webpack")]),v._v(" 处理应⽤程序时，它会递归地构建⼀个依\n赖关系图 ("),_("code",[v._v("dependency graph")]),v._v(")，其中包含应⽤程序需要的每个模块，\n然后将所有这些模块打包成⼀个或多个 "),_("code",[v._v("bundle")]),v._v("。\n因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤"),_("code",[v._v("npm script")]),v._v(" 代\n替 "),_("code",[v._v("Grunt")]),v._v("、"),_("code",[v._v("Gulp")]),v._v("，"),_("code",[v._v("npm script")]),v._v(" 同样可以打造任务流。")]),v._v(" "),_("h3",{attrs:{id:"webpack、rollup、parcel-优劣"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack、rollup、parcel-优劣"}},[v._v("#")]),v._v(" webpack、rollup、parcel 优劣？")]),v._v(" "),_("p",[_("code",[v._v("webpack")]),v._v(" 适⽤于⼤型复杂的前端站点构建: "),_("code",[v._v("webpack")]),v._v(" 有强⼤的 "),_("code",[v._v("loader")]),v._v("\n和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即\n执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，\n值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块\n等,这种情况更适合⽂件依赖复杂的应⽤开发。")]),v._v(" "),_("p",[_("code",[v._v("rollup")]),v._v(" 适⽤于基础库的打包，如 "),_("code",[v._v("vue")]),v._v("、"),_("code",[v._v("d3")]),v._v(" 等: "),_("code",[v._v("Rollup")]),v._v(" 就是将各个模\n块打包进⼀个⽂件中，并且通过 "),_("code",[v._v("Tree-shaking")]),v._v(" 来删除⽆⽤的代码,\n可以最⼤程度上降低代码体积,但是 "),_("code",[v._v("rollup")]),v._v(" 没有 "),_("code",[v._v("webpack")]),v._v(" 如此多的的\n如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适\n合库的开发。")]),v._v(" "),_("p",[_("code",[v._v("parcel")]),v._v(" 适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效\n果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项\n⽬或者实验项⽬不建议使⽤。")]),v._v(" "),_("h3",{attrs:{id:"有哪些常⻅的-loader"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常⻅的-loader"}},[v._v("#")]),v._v(" 有哪些常⻅的 Loader？")]),v._v(" "),_("p",[_("code",[v._v("file-loader")]),v._v("：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 "),_("code",[v._v("URL")]),v._v("去引⽤输出的⽂件")]),v._v(" "),_("p",[_("code",[v._v("url-loader")]),v._v("：和 "),_("code",[v._v("file-loader")]),v._v(" 类似，但是能在⽂件很⼩的情况下以"),_("code",[v._v("base64")]),v._v(" 的⽅式把⽂件内容注⼊到代码中去")]),v._v(" "),_("p",[_("code",[v._v("source-map-loader")]),v._v("：加载额外的 "),_("code",[v._v("Source Map")]),v._v(" ⽂件，以⽅便断点调试")]),v._v(" "),_("p",[_("code",[v._v("image-loader")]),v._v("：加载并且压缩图⽚⽂件")]),v._v(" "),_("p",[_("code",[v._v("babel-loader")]),v._v("：把 "),_("code",[v._v("ES6")]),v._v(" 转换成 "),_("code",[v._v("ES5")])]),v._v(" "),_("p",[_("code",[v._v("css-loader")]),v._v("：加载 "),_("code",[v._v("CSS")]),v._v("，⽀持模块化、压缩、⽂件导⼊等特性")]),v._v(" "),_("p",[_("code",[v._v("style-loader")]),v._v("：把 "),_("code",[v._v("CSS")]),v._v(" 代码注⼊到 "),_("code",[v._v("JavaScript")]),v._v(" 中，通过 "),_("code",[v._v("DOM")]),v._v(" 操作去加载 "),_("code",[v._v("CSS")]),v._v("。")]),v._v(" "),_("p",[_("code",[v._v("eslint-loader")]),v._v("：通过 "),_("code",[v._v("ESLint")]),v._v(" 检查 "),_("code",[v._v("JavaScript")]),v._v(" 代码")]),v._v(" "),_("p",[v._v("注意：在 "),_("code",[v._v("Webpack")]),v._v(" 中，"),_("code",[v._v("loader")]),v._v(" 的执行顺序是从右向左执行的。因为"),_("code",[v._v("webpack")]),v._v(" 选择了 "),_("code",[v._v("compose")]),v._v(" 这样的函数式编程方式，\n这种方式的表达式执行是从右向左的。")]),v._v(" "),_("h3",{attrs:{id:"有哪些常⻅的-plugin"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#有哪些常⻅的-plugin"}},[v._v("#")]),v._v(" 有哪些常⻅的 Plugin？")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("define-plugin")]),v._v("：定义环境变量")]),v._v(" "),_("li",[_("code",[v._v("html-webpack-plugin")]),v._v("：简化 "),_("code",[v._v("html")]),v._v(" ⽂件创建")]),v._v(" "),_("li",[_("code",[v._v("uglifyjs-webpack-plugin")]),v._v("：通过 "),_("code",[v._v("UglifyES")]),v._v(" 压缩 "),_("code",[v._v("ES6")]),v._v(" 代码")]),v._v(" "),_("li",[_("code",[v._v("webpack-parallel-uglify-plugin")]),v._v(": 多核压缩，提⾼压缩速度")]),v._v(" "),_("li",[_("code",[v._v("webpack-bundle-analyzer")]),v._v(": 可视化 "),_("code",[v._v("webpack")]),v._v(" 输出⽂件的体积")]),v._v(" "),_("li",[_("code",[v._v("mini-css-extract-plugin")]),v._v(": "),_("code",[v._v("CSS")]),v._v(" 提取到单独的⽂件中，⽀持按需加载")])]),v._v(" "),_("h3",{attrs:{id:"bundle-chunk-module-是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bundle-chunk-module-是什么"}},[v._v("#")]),v._v(" bundle，chunk，module 是什么？")]),v._v(" "),_("p",[_("code",[v._v("bundle")]),v._v("：是由 "),_("code",[v._v("webpack")]),v._v(" 打包出来的⽂件；\n"),_("code",[v._v("chunk")]),v._v("：代码块，⼀个 "),_("code",[v._v("chunk")]),v._v(" 由多个模块组合⽽成，⽤于代码的合并和分割；\n"),_("code",[v._v("module")]),v._v("：是开发中的单个模块，在 "),_("code",[v._v("webpack")]),v._v(" 的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，\n"),_("code",[v._v("webpack")]),v._v(" 会从配置的 "),_("code",[v._v("entry")]),v._v(" 中递归开始找出所有依赖的模块。")]),v._v(" "),_("h3",{attrs:{id:"loader-和-plugin-的不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#loader-和-plugin-的不同"}},[v._v("#")]),v._v(" Loader 和 Plugin 的不同？")]),v._v(" "),_("p",[_("strong",[v._v("不同的作⽤:")]),v._v(" "),_("code",[v._v("Loader")]),v._v(' 直译为"加载器"。'),_("code",[v._v("Webpack")]),v._v(" 将⼀切⽂件视为模块，但是 "),_("code",[v._v("webpack")]),v._v("原⽣是只能解析 js⽂件，如果想将其他⽂件也打包的话，就会⽤到\n"),_("code",[v._v("loader")]),v._v(" 。 所以 "),_("code",[v._v("Loader")]),v._v(" 的作⽤是让 "),_("code",[v._v("webpack")]),v._v(" 拥有了加载和解析⾮"),_("code",[v._v("JavaScript")]),v._v(" ⽂件的能⼒。")]),v._v(" "),_("p",[_("code",[v._v("Plugin")]),v._v(' 直译为"插件"。'),_("code",[v._v("Plugin")]),v._v(" 可以扩展 "),_("code",[v._v("webpack")]),v._v(" 的功能，让 "),_("code",[v._v("webpack")]),v._v("具有更多的灵活性。在 "),_("code",[v._v("Webpack")]),v._v(" 运⾏的⽣命周期中会⼴播出许多事\n件，"),_("code",[v._v("Plugin")]),v._v(" 可以监听这些事件，在合适的时机通过 "),_("code",[v._v("Webpack")]),v._v(" 提供的"),_("code",[v._v("API")]),v._v(" 改变输出结果。")]),v._v(" "),_("p",[_("strong",[v._v("不同的⽤法:")]),v._v(" "),_("code",[v._v("Loader")]),v._v(" 在 "),_("code",[v._v("module.rules")]),v._v(" 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 "),_("code",[v._v("Object")]),v._v(" ，\n⾥⾯描述了对于什么类型的⽂件（ "),_("code",[v._v("test")]),v._v(" ），使⽤什么加载( "),_("code",[v._v("loader")]),v._v(" )和使⽤的参数（ "),_("code",[v._v("options")]),v._v(" ）")]),v._v(" "),_("p",[_("code",[v._v("Plugin")]),v._v(" 在 "),_("code",[v._v("plugins")]),v._v(" 中单独配置。类型为数组，每⼀项是⼀个 "),_("code",[v._v("plugin")]),v._v("的实例，参数都通过构造函数传⼊。")]),v._v(" "),_("h3",{attrs:{id:"webpack-热更新的实现原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack-热更新的实现原理"}},[v._v("#")]),v._v(" webpack 热更新的实现原理？")]),v._v(" "),_("p",[_("code",[v._v("webpack")]),v._v(" 的热更新⼜称热替换（"),_("code",[v._v("Hot Module Replacement")]),v._v("），缩写为"),_("code",[v._v("HMR")]),v._v("。这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。\n原理：\n"),_("a",{attrs:{href:"/images/qdgch.png"}},[v._v("热更新")])]),v._v(" "),_("p",[v._v("⾸先要知道 "),_("code",[v._v("server")]),v._v(" 端和 "),_("code",[v._v("client")]),v._v(" 端都做了处理⼯作：")]),v._v(" "),_("p",[v._v("第⼀步，在 "),_("code",[v._v("webpack")]),v._v(" 的 "),_("code",[v._v("watch")]),v._v(" 模式下，⽂件系统中某⼀个⽂件发⽣\n修改，"),_("code",[v._v("webpack")]),v._v(" 监听到⽂件变化，根据配置⽂\n件对模块重新编译打包，并将打包后的代码通过简单的 "),_("code",[v._v("JavaScript")]),v._v("对象保存在内存中。")]),v._v(" "),_("p",[v._v("第⼆步是 "),_("code",[v._v("webpack-dev-server")]),v._v(" 和 "),_("code",[v._v("webpack")]),v._v(" 之间的接⼝交互，⽽在这⼀步，主要是 "),_("code",[v._v("dev-server")]),v._v(" 的中间件 "),_("code",[v._v("webpack- dev-middleware")]),v._v("\n和 "),_("code",[v._v("webpack")]),v._v(" 之间的交互，"),_("code",[v._v("webpack-dev-middleware")]),v._v(" 调⽤ "),_("code",[v._v("webpack")]),v._v(" 暴露的 "),_("code",[v._v("API")]),v._v(" 对代码变化进⾏监 控，并且告诉 "),_("code",[v._v("webpack")]),v._v("，将代码打包\n到内存中。")]),v._v(" "),_("p",[v._v("第三步是 "),_("code",[v._v("webpack-dev-server")]),v._v(" 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了\n"),_("code",[v._v("devServer.watchContentBase")]),v._v(" 为 "),_("code",[v._v("true")]),v._v(" 的时候，"),_("code",[v._v("Server")]),v._v(" 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进\n⾏ "),_("code",[v._v("live reload")]),v._v("。注意，这⼉是浏览器刷新，和 "),_("code",[v._v("HMR")]),v._v(" 是两个概念。")]),v._v(" "),_("p",[v._v("第四步也是 "),_("code",[v._v("webpack-dev-server")]),v._v(" 代码的⼯作，该步骤主要是通过\n"),_("code",[v._v("sockjs")]),v._v("（"),_("code",[v._v("webpack-dev-server 的依赖")]),v._v("）在浏览器端和服务端之间建\n⽴⼀个 "),_("code",[v._v("websocket")]),v._v(" ⻓连接，将 "),_("code",[v._v("webpack")]),v._v(" 编译打包的各个阶段的状态\n信息告知浏览器端，同时也包括第三步中 "),_("code",[v._v("Server")]),v._v(" 监听静态⽂件变化\n的信息。浏览器端根据这些 "),_("code",[v._v("socket")]),v._v(" 消息进⾏不同的操作。当然服务\n端传递的最主要信息还是新模块的 "),_("code",[v._v("hash")]),v._v(" 值，后⾯的步骤根据这⼀\n"),_("code",[v._v("hash")]),v._v(" 值来进⾏模块热替换。\n"),_("code",[v._v("webpack-dev-server/client")]),v._v(" 端并不能够请求更新的代码，也不会执\n⾏ 热 更 模 块 操 作 ， ⽽ 把 这 些 ⼯ 作 ⼜ 交 回 给 了 "),_("code",[v._v("webpack")]),v._v(" ，\n"),_("code",[v._v("webpack/hot/dev-server")]),v._v(" 的 ⼯ 作 就 是 根 据\n"),_("code",[v._v("webpack-dev-server/client")]),v._v(" 传给它的信息以及 "),_("code",[v._v("dev-server")]),v._v(" 的配\n置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏\n览器，也就没有后⾯那些步骤了。\n"),_("code",[v._v("HotModuleReplacement.runtime")]),v._v(" 是客户端 "),_("code",[v._v("HMR")]),v._v(" 的中枢，它接收到上\n⼀ 步 传 递 给 他 的 新 模 块 的 "),_("code",[v._v("hash")]),v._v(" 值 ， 它 通 过\n"),_("code",[v._v("JsonpMainTemplate.runtime")]),v._v(" 向 "),_("code",[v._v("server")]),v._v(" 端发送 "),_("code",[v._v("Ajax")]),v._v(" 请求，服务端\n返回⼀个 "),_("code",[v._v("json")]),v._v("，该 "),_("code",[v._v("json")]),v._v(" 包含了所有要更新的模块的 hash 值，获\n取到更新列表后，该模块再次通过 "),_("code",[v._v("jsonp")]),v._v(" 请求，获取到最新的模块\n代码。这就是上图中 7、8、9 步骤。\n⽽第 10 步是决定 "),_("code",[v._v("HMR")]),v._v(" 成功与否的关键步骤，在该步骤中，\n"),_("code",[v._v("HotModulePlugin")]),v._v(" 将会对新旧模块进⾏对⽐，决定是否更新模块，在\n决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模\n块间的依赖引⽤。\n最后⼀步，当 "),_("code",[v._v("HMR")]),v._v(" 失败后，回退到 "),_("code",[v._v("live reload")]),v._v(" 操作，也就是进⾏\n浏览器刷新来获取最新打包代码。")]),v._v(" "),_("h3",{attrs:{id:"babel-的原理是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#babel-的原理是什么"}},[v._v("#")]),v._v(" Babel 的原理是什么?")]),v._v(" "),_("p",[_("code",[v._v("babel")]),v._v(" 的转译过程也分为三个阶段，这三步具体是：\n解析 "),_("code",[v._v("Parse")]),v._v(": 将代码解析⽣成抽象语法树（"),_("code",[v._v("AST")]),v._v("），即词法分析与语法分析的过程；")]),v._v(" "),_("p",[v._v("转换 "),_("code",[v._v("Transform")]),v._v(": 对于 "),_("code",[v._v("AST")]),v._v(" 进⾏变换⼀系列的操作，"),_("code",[v._v("babel")]),v._v(" 接受得到 "),_("code",[v._v("AST")]),v._v(" 并通过 "),_("code",[v._v("babel-traverse")]),v._v(" 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；")]),v._v(" "),_("p",[v._v("⽣成 "),_("code",[v._v("Generate")]),v._v(": 将变换后的 "),_("code",[v._v("AST")]),v._v(" 再转换为 "),_("code",[v._v("JS")]),v._v(" 代码, 使⽤到的模块是 "),_("code",[v._v("babel-generator")]),v._v("。")]),v._v(" "),_("p",[_("a",{attrs:{href:"/images/qdgch02.png"}},[v._v("babel原理图")])]),v._v(" "),_("h3",{attrs:{id:"git-和-svn-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#git-和-svn-的区别"}},[v._v("#")]),v._v(" git 和 svn 的区别")])])}),[],!1,null,null,null);e.default=d.exports}}]);